# Scenario 2 Analysis: New Customer and New Product (Dimension Creation Test)

## Test Scenario Requirements

The scenario requires that when a new customer and new product appear in an order:
1. ✅ New customer appears in `dim_user` (or `customer_table`) with valid surrogate key
2. ✅ New product appears in `dim_product` (or `product_table`) with valid surrogate key  
3. ✅ Fact row correctly references these new surrogate keys (no null or broken FKs)
4. ✅ Transaction appears correctly on dashboard when filtered by new customer/product

## Current System Analysis

### ✅ **What Works**

1. **Dimension Upsert Logic**: 
   - Both `dim_user` and `dim_product` use `ON CONFLICT DO UPDATE` (upsert pattern)
   - This means they CAN handle new entries when data is provided
   - Location: `load_dim.py` lines 77-89 (products), 107-121 (users)

2. **Surrogate Key Generation**:
   - Surrogate keys (`user_sk`, `product_sk`) are auto-generated by PostgreSQL `SERIAL` type
   - Location: Schema definition in `sql/01_create_schema_from_physical_model.sql`

3. **Fact Table Foreign Keys**:
   - Fact tables correctly reference dimension surrogate keys
   - `fact_orders` references `user_sk` (line 267 in `load_fact.py`)
   - `fact_line_items` references `product_sk` (line 433 in `load_fact.py`)

### ❌ **Critical Gap: Missing Dimension Creation from Fact Data**

**The Problem:**

The system assumes dimensions are loaded from **separate source files**:
- Users come from `*user_data*` files → loaded into `dim_user`
- Products come from `*product_list*` files → loaded into `dim_product`

**However, when fact loading occurs:**
- `load_fact_orders()` pre-loads dimension mappings at START (line 170 in `load_fact.py`)
- If a `user_id` is not in `dim_user`, the order is **SKIPPED** (lines 212-216)
- `load_fact_line_items()` pre-loads product mappings at START (line 374)
- If a `product_id` is not in `dim_product`, the line item is **SKIPPED** (lines 417-421)

**Result:** If a new customer/product appears **ONLY in order/line_item data** (not in separate dimension files), they will:
1. ❌ NOT be created in dimension tables
2. ❌ Cause fact rows to be skipped
3. ❌ NOT appear on dashboard

### Code Evidence

**In `load_fact.py` (lines 208-216):**
```python
user_sk = user_map.get(user_id) if user_id else None

if not user_sk:
    skipped_no_user += 1
    if skipped_no_user <= 5:
        logging.debug(f"Skipping order {row.get('order_id')}: user_id '{user_id}' not found in dim_user")
    continue  # ❌ SKIPS THE ORDER
```

**In `load_fact.py` (lines 416-421):**
```python
product_sk = product_map.get(product_id)
if not product_sk:
    skipped_no_product += 1
    if skipped_no_product <= 5:
        logging.debug(f"Skipping line item {row.get('order_id')}: product_id '{product_id}' not found in dim_product")
    continue  # ❌ SKIPS THE LINE ITEM
```

## Required Solution

To support Scenario 2, the system needs **"Late-Arriving Dimension"** handling:

### Option 1: Extract Dimensions from Fact Data (Recommended)

**Before loading facts, extract and create missing dimensions:**

1. **For Customers:**
   - Extract unique `user_id` values from `order_data`
   - Check which ones don't exist in `dim_user`
   - Create minimal `dim_user` entries for missing users (with NULL/default values for missing attributes)
   - Re-load dimension mappings

2. **For Products:**
   - Extract unique `product_id` values from `line_item_data_products`
   - Check which ones don't exist in `dim_product`
   - Create minimal `dim_product` entries for missing products (with NULL/default values)
   - Re-load dimension mappings

**Implementation Location:** Add new functions in `load_dim.py`:
- `create_missing_users_from_orders(order_df)`
- `create_missing_products_from_line_items(products_df)`

**Call these BEFORE fact loading** in the main pipeline.

### Option 2: Lazy Dimension Creation During Fact Loading

**Modify fact loading to create dimensions on-the-fly:**

Instead of skipping when dimension key is missing:
1. Create dimension entry with minimal data
2. Get the newly created surrogate key
3. Use it for the fact row

**Pros:** More dynamic, handles edge cases
**Cons:** Slower (per-row database operations), more complex error handling

## Current Workflow Order

```
1. Ingest → Staging Tables
2. Extract → DataFrames
3. Transform → Cleaned DataFrames
4. Load Dimensions → dim_user, dim_product (from separate files only)
5. Load Facts → fact_orders, fact_line_items (skips if dimension missing)
```

## Required Workflow Order (After Fix)

```
1. Ingest → Staging Tables
2. Extract → DataFrames
3. Transform → Cleaned DataFrames
4. Load Dimensions → dim_user, dim_product (from separate files)
5. **Extract Missing Dimensions from Fact Data** → NEW STEP
6. **Create Missing Dimensions** → NEW STEP
7. **Reload Dimension Mappings** → NEW STEP
8. Load Facts → fact_orders, fact_line_items (now all dimensions exist)
```

## Test Case Validation

To validate Scenario 2 works:

1. **Prepare test data:**
   - Create order with `user_id = "NEW_USER_123"` (not in any user_data file)
   - Create line item with `product_id = "NEW_PRODUCT_456"` (not in any product_list file)

2. **Run full workflow**

3. **Validate:**
   ```sql
   -- Check new customer exists
   SELECT user_sk, user_id, name 
   FROM dim_user 
   WHERE user_id = 'NEW_USER_123';
   -- Expected: 1 row with valid user_sk
   
   -- Check new product exists
   SELECT product_sk, product_id, product_name 
   FROM dim_product 
   WHERE product_id = 'NEW_PRODUCT_456';
   -- Expected: 1 row with valid product_sk
   
   -- Check fact row references them correctly
   SELECT fo.order_id, fo.user_sk, li.product_sk
   FROM fact_orders fo
   JOIN fact_line_items li ON fo.order_id = li.order_id
   WHERE fo.user_sk = (SELECT user_sk FROM dim_user WHERE user_id = 'NEW_USER_123')
     AND li.product_sk = (SELECT product_sk FROM dim_product WHERE product_id = 'NEW_PRODUCT_456');
   -- Expected: 1 row with non-null FKs
   ```

## Recommendation

**Implement Option 1** (Extract Dimensions from Fact Data) because:
- ✅ Cleaner separation of concerns
- ✅ Better performance (bulk operations)
- ✅ Easier to test and debug
- ✅ Follows ETL best practices

**Estimated Implementation Effort:**
- Add 2 new functions to `load_dim.py` (~100 lines)
- Modify main pipeline to call them before fact loading (~10 lines)
- Add unit tests (~50 lines)
- **Total: ~160 lines of code**

## Implementation Status: ✅ **IMPLEMENTED - HANDLES SCENARIO 2**

### Implementation Details

**Option 1 has been implemented** with the following changes:

1. **New Functions in `load_dim.py`:**
   - `create_missing_users_from_orders(order_df)` - Extracts unique user_ids from order data and creates minimal dim_user entries for missing users
   - `create_missing_products_from_line_items(products_df)` - Extracts unique product_ids from line item data and creates minimal dim_product entries for missing products

2. **Workflow Integration:**
   - Updated `run_load_fact()` in `workflows/shopzada_etl_pipeline.py` to call these functions before fact loading
   - Updated `main()` in `scripts/etl_pipeline_python.py` to support standalone execution

3. **How It Works:**
   - Before loading facts, the system extracts unique user_ids from order data
   - Checks which user_ids don't exist in `dim_user`
   - Creates minimal `dim_user` entries (with NULL values for attributes not in order data)
   - Same process for products from line item data
   - Then proceeds with fact loading (now all dimensions exist)

4. **Key Features:**
   - Uses `ON CONFLICT DO NOTHING` to safely handle race conditions
   - Creates minimal dimension entries (NULL values for missing attributes)
   - Logs creation counts for monitoring
   - Works with both workflow and standalone execution

### Current Status: ✅ **HANDLES SCENARIO 2**

The system will **PASS** Scenario 2 because:
- ✅ New customers/products in orders are **created** in dimension tables before fact loading
- ✅ Mechanism exists to create dimensions from fact data
- ✅ Dashboard will show these transactions correctly
- ✅ Fact rows will have valid foreign keys (no null or broken FKs)

